import sublime, sublime_plugin
import sys, os, re, zipfile
from random import random

PREFERENCES = 'Preferences.sublime-settings'
FAVORITES = 'SchemrFavorites.sublime-settings'

is_ST2 = int(sublime.version()) < 3000

if not is_ST2:
	import Schemr.lib.plist_parser as parser
else:
	sys.path.append(os.path.join(os.path.dirname(__file__), 'lib'))
	import plist_parser as parser

	# Contains various common, internal functions for Schemr.
class Schemr(object):
	_instance = None

	@classmethod
	def instance(cls):
		if not cls._instance:
			cls._instance = cls()
		return cls._instance

	def __init__(self):
		self.preferences = sublime.load_settings(PREFERENCES)
		self.favorites = sublime.load_settings(FAVORITES)

		# Returns a list of all managed schemes.  Each scheme is itself represented by a list
		# that contains, in order, (1) its pretty-printed name, (2) its path and (3) whether
		# or not it is favorited (True or False).
	def load_schemes(self):
		all_scheme_paths = []
		favorite_scheme_paths = self.get_favorites()

		try: # use find_resources() first for ST3.
			all_scheme_paths = sublime.find_resources('*.tmTheme')

		except: # fallback to walk() for ST2
			# Load the paths for schemes contained in zipped .sublime-package files.
			for root, dirs, files in os.walk(sublime.installed_packages_path()):
				for package in (package for package in files if package.endswith('.sublime-package')):
					zf = zipfile.ZipFile(os.path.join(sublime.installed_packages_path(), package))
					for filename in (filename for filename in zf.namelist() if filename.endswith('.tmTheme')):
						filepath = os.path.join(root, package, filename).replace(sublime.installed_packages_path(), 'Packages').replace('.sublime-package', '').replace('\\', '/')
						all_scheme_paths.append(filepath)

			# Load the paths for schemes contained in folders.
			for root, dirs, files in os.walk(sublime.packages_path()):
				for filename in (filename for filename in files if filename.endswith('.tmTheme')):
					filepath = os.path.join(root, filename).replace(sublime.packages_path(), 'Packages').replace('\\', '/')
					all_scheme_paths.append(filepath)

		# Filter schemes generated by known plugins.
		regex = re.compile('\(SL\)|\(Color\ Highlighter\)', re.IGNORECASE)
		all_scheme_paths = [scheme for scheme in all_scheme_paths if not regex.search(scheme)]

		# Given the paths of all the color schemes, add in the information for
		# the pretty-printed name and whether or not it's been favorited.
		all_schemes = []
		for scheme_path in all_scheme_paths:
			scheme_name = self.filter_scheme_name(scheme_path)
			favorite = ''
			is_favorited = scheme_path in favorite_scheme_paths
			if is_favorited: favorite = u'   \u2605' # Put a pretty star icon next to favorited schemes. :)
			all_schemes.append([scheme_name, scheme_path, favorite])

		all_schemes.sort(key=lambda s: s[0].lower())
		return all_schemes

		# Displayes the given schemes in a quick-panel, letting the user cycle through
		# them to preview them and possibly select one.  The reason that this is a method
		# here instead of a free-standing command is that the "List all schemes" and
		# "List favorite schemes" commands function exactly the same except for the
		# underlying schemes that they operate on.  This method exists to provide that
		# common listing functionality.
	def list_schemes(self, window, schemes):
		# Get the user-defined settings or return default values.
		schemr_brightness_theshold = self.preferences.get('schemr_brightness_theshold', 100)
		schemr_brightness_flags = self.preferences.get('schemr_brightness_flags', True)
		schemr_preview_selection = self.preferences.get('schemr_preview_selection', True)

		the_scheme_path = self.get_scheme()
		the_scheme_name = self.filter_scheme_name(the_scheme_path)

		# If the active scheme isn't part of the supplied pool (the schemes variable),
		# then we can't skip the selection to that point and the best we can do is
		# start from the top of the list.
		try:
			the_index = [scheme[0] for scheme in schemes].index(the_scheme_name)
		except (ValueError):
			the_index = 0

		# Build the display list of color schemes.
		if schemr_brightness_flags:
			color_schemes = list()

			# Add a brightness flag to each scheme name if the luminance
			# is above or below the schemr_brightness_threshold value.
			for scheme in schemes:
				# Get the RGB value of the scheme background and convert to luminance value.
				rgb = self.parse_scheme(scheme[1])
				luminance = (0.2126 * rgb[0]) + (0.7152 * rgb[1]) + (0.0722 * rgb[2])
				if luminance < schemr_brightness_theshold:
					flag = '   [Dark]'
				else:
					flag = '   [Light]'

				color_schemes.append([scheme[0] + flag + scheme[2], scheme[1]])

		else:
			color_schemes = [[scheme[0] + scheme[2], scheme[1]] for scheme in schemes]

		def on_done(index):
			if index is -1:
				self.set_scheme(the_scheme_path)
			else:
				self.set_scheme(color_schemes[index][1])
				sublime.status_message('Scheme: ' + self.filter_scheme_name(color_schemes[index][1]))

		# Set a selection flag to detect when the panel is first opened in some
		# versions of Sublime Text. This prevents the color scheme from 'flickering'
		# from one scheme to another as the panel jumps to the active selection.
		self.user_selected = False
		def on_select(index):
			if self.user_selected is True:
				self.set_scheme(color_schemes[index][1])
			else:
				self.user_selected = True

		try: # Attempt to enable preview-on-selection (only supported by Sublime Text 3).
			if schemr_preview_selection is True:
				window.show_quick_panel(color_schemes, on_done, 0, the_index, on_select)
			else:
				window.show_quick_panel(color_schemes, on_done, 0, the_index)
		except:
			window.show_quick_panel(color_schemes, on_done)

		# Cycles the scheme in the given direction ("next", "prev" or "rand").
	def cycle_schemes(self, schemes, direction):
		the_scheme_name = self.filter_scheme_name(self.get_scheme())
		num_of_schemes = len(schemes)

		# Try to find the current scheme path in the available schemes otherwise
		# start from the top of the list. Useful in case the user has manually
		# saved an invalid scheme path or the current scheme file is not available.
		try:
			the_index = [scheme[0] for scheme in schemes].index(the_scheme_name)
		except (ValueError):
			the_index = 0

		if direction == 'next':
			index = the_index + 1 if the_index < num_of_schemes - 1 else 0

		if direction == 'prev':
			index = the_index - 1 if the_index > 0 else num_of_schemes - 1

		if direction == 'rand':
			index = int(random() * len(schemes))

		self.set_scheme(schemes[index][1])
		sublime.status_message('Scheme: ' + self.filter_scheme_name(schemes[index][1]))

		# Parse the scheme file for the background color and return the RGB values
		# in order to determine if the scheme is Dark or Light. Use load_resources()
		# first for ST3 or fallback to the absolute path for ST2.
	def parse_scheme(self, scheme_path):
		if not is_ST2:
			try:
				xml = sublime.load_resource(scheme_path)
			except:
				print('Error loading ' + scheme_path)
				return (0, 0, 0)
			try:
				plist = parser.parse_string(xml)
			except (parser.PropertyListParseError):
				print('Error parsing ' + scheme_path)
				return (0, 0, 0)
		else:
			xml = os.path.join(sublime.packages_path(), scheme_path.replace('Packages/', ''))
			try:
				plist = parser.parse_file(xml)
			except (parser.PropertyListParseError):
				print('Error parsing ' + scheme_path)
				return (0, 0, 0)

		try:
			background_color = plist['settings'][0]['settings']['background'].lstrip('#')
		except (KeyError): # tmTheme is missing a background color
			return (0, 0, 0)

		if len(background_color) is 3:
			# Shorthand value, e.g. #111
			# Repeat the values for correct base 16 conversion.
			r, g, b = background_color[:1] + background_color[:1], background_color[1:2] + background_color[1:2], background_color[2:] + background_color[2:]
		else:
			# Full-length color value, e.g. #111111 or #FFEEEEEE
			# Here we assume the order of hex values is #AARRGGBB
			# and so work backwards from the end of the string.
			r, g, b = background_color[-6:-4], background_color[-4:-2], background_color[-2:]

		r, g, b = [int(n, 16) for n in (r, g, b)]
		return (r, g, b)

	def set_scheme(self, scheme):
		self.preferences.set('color_scheme', scheme)
		sublime.save_settings(PREFERENCES)

	def get_scheme(self):
		return self.preferences.get('color_scheme')

	def set_favorites(self, schemes):
		self.favorites.set('schemr_favorites', schemes)
		sublime.save_settings(FAVORITES)

	def get_favorites(self):
		return self.favorites.get('schemr_favorites')

	def filter_scheme_name(self, scheme_path):
		regex = re.compile('(\ \(SL\))|(\ Color\ Highlighter)?.tmTheme', re.IGNORECASE)
		scheme_name = re.sub(regex, '', scheme_path).split('/').pop()
		return scheme_name

	def find_scheme(self, scheme_path):
		scheme_name = self.filter_scheme_name(scheme_path)
		matching_paths = [path for name, path, favorited in self.load_schemes() if name == scheme_name]
		if len(matching_paths) is not 0:
			return matching_paths[0]
		else:
			return False

	# Called when Sublime API is ready [ST3].
def plugin_loaded():
	Schemr.instance()

	# Display the full list of schemes available, regardless
	# of whether or not they are favorited.
class SchemrListSchemesCommand(sublime_plugin.WindowCommand):
	def run(self):
		Schemr.instance().list_schemes(self.window, Schemr.instance().load_schemes())

	# Display the list of schemes that have been favorited.
	# Only available if there are favorites to display.
class SchemrListFavoriteSchemesCommand(sublime_plugin.WindowCommand):
	def run(self):
		Schemr.instance().list_schemes(self.window, [scheme for scheme in Schemr.instance().load_schemes() if scheme[2]])

	def is_enabled(self):
		return len(Schemr.instance().get_favorites()) > 0

	# SchemrFavoriteCurrentSchemeCommand and SchemrUnfavoriteCurrentSchemeCommand
	# work in conjunction. Only one is ever available to the user at a time,
	# depending on whether or not the active scheme is already favorited.
class SchemrFavoriteCurrentSchemeCommand(sublime_plugin.WindowCommand):
	def run(self):
		the_scheme = Schemr.instance().find_scheme(Schemr.instance().get_scheme())
		if the_scheme is not False:
			favorites = Schemr.instance().get_favorites()
			favorites.append(the_scheme)
			Schemr.instance().set_favorites(favorites)

	def is_enabled(self):
		return Schemr.instance().find_scheme(Schemr.instance().get_scheme()) not in Schemr.instance().get_favorites()

class SchemrUnfavoriteCurrentSchemeCommand(sublime_plugin.WindowCommand):
	def run(self):
		the_scheme = Schemr.instance().find_scheme(Schemr.instance().get_scheme())
		if the_scheme is not False:
			favorites = Schemr.instance().get_favorites()
			favorites.remove(the_scheme)
			Schemr.instance().set_favorites(favorites)

	def is_enabled(self):
		return Schemr.instance().find_scheme(Schemr.instance().get_scheme()) in Schemr.instance().get_favorites()

	# Cycles the full list of schemes that are available
	# regardless of whether or not they are favorited.
class SchemrCycleSchemesCommand(sublime_plugin.WindowCommand):
	def run(self, direction):
		Schemr.instance().cycle_schemes(Schemr.instance().load_schemes(), direction)

	# Cycles the list of schemes that have been favorited. This command is
	# only available if the number of favorites is enough to cycle through.
class SchemrCycleFavoriteSchemesCommand(sublime_plugin.WindowCommand):
	def run(self, direction):
		Schemr.instance().cycle_schemes([scheme for scheme in Schemr.instance().load_schemes() if scheme[2]], direction)

	def is_enabled(self):
		return len(Schemr.instance().get_favorites()) > 1

class SchemrSetSyntaxSchemeCommand(sublime_plugin.TextCommand):
	def run(self, edit):
		the_scheme = Schemr.instance().get_scheme()
		syntax_path = self.view.settings().get('syntax')
		syntax_preferences = os.path.splitext(os.path.basename(syntax_path))[0] + '.sublime-settings'

		sublime.load_settings(syntax_preferences).set('color_scheme', the_scheme)
		sublime.save_settings(syntax_preferences)

class SchemrResetSyntaxSchemeCommand(sublime_plugin.TextCommand):
	def run(self, edit):
		syntax_path = self.view.settings().get('syntax')
		syntax_preferences = os.path.splitext(os.path.basename(syntax_path))[0] + '.sublime-settings'

		sublime.load_settings(syntax_preferences).erase('color_scheme')
		sublime.save_settings(syntax_preferences)

	def is_enabled(self):
		syntax_path = self.view.settings().get('syntax')
		syntax_name = os.path.splitext(os.path.basename(syntax_path))[0]
		syntax_preferences = syntax_name + '.sublime-settings'

		return sublime.load_settings(syntax_preferences).has('color_scheme')

	# These commands are provided for backwards-compatibility.
	# SchemrCycleSchemeCommand should be used instead.
class SchemrNextSchemeCommand(sublime_plugin.WindowCommand):
	def run(self):
		self.window.run_command('schemr_cycle_schemes', {'direction': 'next'})
class SchemrPreviousSchemeCommand(sublime_plugin.WindowCommand):
	def run(self):
		self.window.run_command('schemr_cycle_schemes', {'direction': 'prev'})
class SchemrRandomSchemeCommand(sublime_plugin.WindowCommand):
	def run(self):
		self.window.run_command('schemr_cycle_schemes', {'direction': 'rand'})

if is_ST2: plugin_loaded()
